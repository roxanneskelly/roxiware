require 'omniauth'
require 'oauth'
require 'net/http'
module OmniAuth
    module Strategies

        # Authproxy performs proxy logins, as various providers require that
	# the callback URI be on a registered server.  It's untenable that
	# we add a registraion for each of the customer sites.
	# It performs all of the initial work to get the appropriate 'tokens'
	# used to log in, as well as gathering some user information
	# It should also do some cross-site checking, to validate
	# the requesting site is a scribaroo site.
        class Authproxy
	    include OmniAuth::Strategy
	    option :consumer_key, nil
	    option :consumer_secret, nil
            option :twitter_client_options, {:authorize_path => '/oauth/authenticate',
                                     :site => 'https://api.twitter.com',
                                     :proxy => ENV['http_proxy'] ? URI(ENV['http_proxy']) : nil}

            option :auth_server, "https://api.twitter.com/"

	    info do 
	       {'login_url' => @login_url, 'auth_kind'=>@auth_kind}
            end

	    # Redirect to the UI on the auth server that throws up the appropriate login dialog
	    # The dialog will collect the appropriate information for the auth provider
	    # and will set up local cookies and such
	    def request_phase
	        case request.params["provider"]
		   when "facebook"
		       # for facebook, application state is in the state parameter
		       redirect  "http://www.facebook.com/dialog/oauth/?client_id=#{AppConfig.facebook_app_id}&state=#{request.params['oauth_state']}&redirect_uri=#{options.callback_server}&display=popup"
		   when "twitter"
		       # for facebook, application state is in the oauth_state parameter
		       # for twitter, we must first retrieve a request token
		       consumer = ::OAuth::Consumer.new(options.twitter_consumer_key, options.twitter_consumer_secret, options.twitter_client_options)
                       request_token = consumer.get_request_token({:oauth_callback => callback_url}, options.request_params)
                       session['oauth'] ||= {}
                       session['oauth']['twitter'] ||= {}
                       session['oauth']['twitter'] = {'callback_confirmed' => request_token.callback_confirmed?, 'request_token' => request_token.token, 'request_secret' => request_token.secret}
                       if request_token.callback_confirmed?
                           redirect request_token.authorize_url(options[:authorize_params])
                       else
                           redirect request_token.authorize_url(options[:authorize_params].merge(:oauth_callback => callback_url))
                       end
                   else
		end
	    end


	    # when callback happens, unpack 
            def callback_phase
	        # unpack the auth state.  The auth-state was generated by a scribaroo site,
		# so successful unpacking indicates that it is allowed
		if request.params["oauth_state"].present?
	            auth_state = ::Roxiware::AuthHelpers::AuthState.new(request.params["oauth_state"].to_s)
		elsif request.params["state"].present?
		    auth_state = ::Roxiware::AuthHelpers::AuthState.new(request.params["state"].to_s)
                else
                    return fail!(:internal_server_error)
		end
		query = Rack::Utils.parse_query(URI(request.url).query)
		query.delete("state")

		if auth_state.blank?
		    return fail!(:invalid_credentials)
		end

		query["is_proxy"]=auth_state.proxy?
                puts "QUERY IS " + query.inspect
	        @auth_kind = auth_state.auth_kind
		@login_url = "http://#{auth_state.host_with_port}/account/auth/#{auth_state.auth_kind}/callback?"+query.collect{|query_val| query_val.join("=")}.join("&")
		super
	    end
	end
    end
end
